"""Vulnerability data model."""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional
import uuid


class Severity(Enum):
    """Vulnerability severity levels."""
    INFORMATIONAL = "informational"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class Confidence(Enum):
    """Confidence levels for findings."""
    FALSE_POSITIVE = "false_positive"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CONFIRMED = "confirmed"


# CWE to severity mapping
CWE_SEVERITY = {
    78: Severity.CRITICAL,   # Command Injection
    89: Severity.CRITICAL,   # SQL Injection
    79: Severity.HIGH,       # XSS
    98: Severity.HIGH,       # LFI
    22: Severity.HIGH,       # Path Traversal
    918: Severity.HIGH,      # SSRF
    611: Severity.HIGH,      # XXE
    917: Severity.CRITICAL,  # Log4Shell
    352: Severity.MEDIUM,    # CSRF
    1336: Severity.HIGH,     # SSTI
}


@dataclass
class Vulnerability:
    """Represents a detected vulnerability."""

    # Identification
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    vulnerability_type: str = ""
    cweid: int = 0

    # Location
    url: str = ""
    parameter: str = ""
    method: str = "GET"

    # Classification
    severity: Severity = Severity.MEDIUM
    confidence_level: Confidence = Confidence.MEDIUM
    confidence_score: float = 0.0

    # Evidence
    payload: str = ""
    evidence: str = ""
    indicators: List[str] = field(default_factory=list)

    # Context
    request_headers: Dict[str, str] = field(default_factory=dict)
    response_snippet: str = ""
    status_code: int = 0

    # Timing
    discovered_at: datetime = field(default_factory=datetime.utcnow)

    # Agent info
    agent_id: str = ""
    stage: str = ""
    reasoning: List[str] = field(default_factory=list)

    # Chaining
    chained_from: Optional[str] = None
    chain_opportunities: List[str] = field(default_factory=list)

    def __post_init__(self):
        # Set severity based on CWE if not explicitly set
        if self.severity == Severity.MEDIUM and self.cweid in CWE_SEVERITY:
            self.severity = CWE_SEVERITY[self.cweid]

        # Set confidence level based on score
        if self.confidence_score >= 0.9:
            self.confidence_level = Confidence.CONFIRMED
        elif self.confidence_score >= 0.7:
            self.confidence_level = Confidence.HIGH
        elif self.confidence_score >= 0.5:
            self.confidence_level = Confidence.MEDIUM
        elif self.confidence_score >= 0.3:
            self.confidence_level = Confidence.LOW
        else:
            self.confidence_level = Confidence.FALSE_POSITIVE

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "vulnerability_type": self.vulnerability_type,
            "cweid": self.cweid,
            "url": self.url,
            "parameter": self.parameter,
            "method": self.method,
            "severity": self.severity.value,
            "confidence_level": self.confidence_level.value,
            "confidence_score": self.confidence_score,
            "payload": self.payload,
            "evidence": self.evidence,
            "indicators": self.indicators,
            "request_headers": self.request_headers,
            "response_snippet": self.response_snippet[:500] if self.response_snippet else "",
            "status_code": self.status_code,
            "discovered_at": self.discovered_at.isoformat(),
            "agent_id": self.agent_id,
            "stage": self.stage,
            "reasoning": self.reasoning,
            "chained_from": self.chained_from,
            "chain_opportunities": self.chain_opportunities,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Vulnerability":
        """Create from dictionary."""
        return cls(
            id=data.get("id", str(uuid.uuid4())),
            vulnerability_type=data.get("vulnerability_type", ""),
            cweid=data.get("cweid", 0),
            url=data.get("url", ""),
            parameter=data.get("parameter", ""),
            method=data.get("method", "GET"),
            severity=Severity(data.get("severity", "medium")),
            confidence_level=Confidence(data.get("confidence_level", "medium")),
            confidence_score=data.get("confidence_score", 0.0),
            payload=data.get("payload", ""),
            evidence=data.get("evidence", ""),
            indicators=data.get("indicators", []),
            request_headers=data.get("request_headers", {}),
            response_snippet=data.get("response_snippet", ""),
            status_code=data.get("status_code", 0),
            discovered_at=datetime.fromisoformat(data["discovered_at"])
            if "discovered_at" in data else datetime.utcnow(),
            agent_id=data.get("agent_id", ""),
            stage=data.get("stage", ""),
            reasoning=data.get("reasoning", []),
            chained_from=data.get("chained_from"),
            chain_opportunities=data.get("chain_opportunities", []),
        )

    @property
    def cwe_url(self) -> str:
        """Get CWE reference URL."""
        return f"https://cwe.mitre.org/data/definitions/{self.cweid}.html"

    @property
    def owasp_category(self) -> str:
        """Get OWASP Top 10 category based on CWE."""
        owasp_mapping = {
            78: "A03:2021 - Injection",
            89: "A03:2021 - Injection",
            79: "A03:2021 - Injection",
            98: "A03:2021 - Injection",
            22: "A01:2021 - Broken Access Control",
            918: "A10:2021 - SSRF",
            611: "A05:2021 - Security Misconfiguration",
            917: "A03:2021 - Injection",
            352: "A01:2021 - Broken Access Control",
            1336: "A03:2021 - Injection",
        }
        return owasp_mapping.get(self.cweid, "Unknown")

    def get_remediation(self) -> str:
        """Get remediation guidance."""
        remediations = {
            "sqli": "Use parameterized queries/prepared statements. Validate and sanitize all input.",
            "xss": "Encode output, use Content-Security-Policy, validate input.",
            "cmdi": "Avoid shell commands, use safe APIs, validate/sanitize input.",
            "lfi": "Use allowlists for file paths, validate input, avoid user-controlled paths.",
            "ssrf": "Use allowlists for URLs, disable unnecessary protocols, validate input.",
            "xxe": "Disable external entities, use safe XML parsers, validate input.",
            "log4shell": "Update Log4j to 2.17.1+, remove JNDI lookup, use safe patterns.",
            "csrf": "Implement CSRF tokens, use SameSite cookies, validate origin.",
            "ssti": "Use logic-less templates, sandbox templates, validate input.",
            "path_traversal": "Use allowlists, validate paths, avoid user-controlled paths.",
        }
        return remediations.get(self.vulnerability_type, "Review and address the vulnerability.")
